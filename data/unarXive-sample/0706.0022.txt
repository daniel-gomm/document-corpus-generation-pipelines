
=1
=1
Modeling Computations in a Semantic Network
Marko A. Rodriguez
Digital Library Research and Prototyping Team
Los Alamos National Laboratory
Los Alamos, New Mexico 87545
Johan Bollen
Digital Library Research and Prototyping Team
Los Alamos National Laboratory
Los Alamos, New Mexico 87545
2020/09/07 10:20:35

Semantic network research has seen a resurgence from its early history in the cognitive sciences with the inception of the Semantic Web initiative. The Semantic Web effort has brought forth an array of technologies that support the encoding, storage, and querying of the semantic network data structure at the world stage. Currently, the popular conception of the Semantic Web is that of a data modeling medium where real and conceptual entities are related in semantically meaningful ways. However, new models have emerged that explicitly encode procedural information within the semantic network substrate. With these new technologies, the Semantic Web has evolved from a data modeling medium to a computational medium. This article provides a classification of existing computational modeling efforts and the requirements of supporting technologies that will aid in the further growth of this burgeoning domain.
keywords: I.2.12 Intelligent Web Services and Semantic Web - I.2.4.k Semantic networks - I.2.4 Knowledge Representation Formalisms and Methods - I.2 Artificial Intelligence - I Computing Methodologies
Introduction
A semantic network is generally defined by a directed labeled graph {{cite:4ed02656-6140-47e8-92d9-00e21bf096ea}}. Formally, a directed labeled graph can be represented in set theoretic notation as FORMULA , where FORMULA  is the set of vertices, FORMULA  is the set of edges, and FORMULA  is a function that maps the edges in FORMULA  to the set of labels in FORMULA . Another perspective would organize each label type according to its own edge group and in such cases, FORMULA , where FORMULA  is the set of all labeled edge sets, FORMULA  is a particular labeled edge set, and FORMULA  {{cite:0bc29d27-2c22-4561-90e9-63c2bf1302a9}}.
For the Semantic Web, the semantic network substrate is defined by the constraints of the Resource Description Framework (RDF) {{cite:c9f8a05f-88cf-49bb-9362-c81768cfa5a7}}, {{cite:4891d4b5-6b8b-4359-b5d7-bdd5beee7f5a}}. RDF represents a semantic network as a set of triples where both vertices and edge labels are called resources. In RDF, a subject resource (FORMULA ) points to an object resource (FORMULA ) according to a predicate resource (FORMULA ). Subject and predicate resources are identified by Uniform Resource Identifiers (URI) {{cite:4e6c020a-3b81-4b19-a125-018e52d3e634}} and the object is either a literal or a URI. If FORMULA  is the set of all URIs and FORMULA  is the set of all literals, then the Semantic Web can be formally defined as FORMULA . This representation is called a triple list where a triple FORMULA . RDF is a framework (or model) for denoting a semantic network in terms of URIs and literals. RDF is not tied to a particular syntax. Various RDF syntaxes have been developed to support the encoding and distribution of RDF graphs {{cite:14af8bdd-9cd4-4e81-96f8-27ee45138d30}}.
Ontology languages have been developed to constrain the topological features of the Semantic Web. The Resource Description Framework Schema (RDFS) supports the representation of subclassing, instantiation, and domain/range restrictions on predicates {{cite:4891d4b5-6b8b-4359-b5d7-bdd5beee7f5a}}. The Web Ontology Language (OWL) was developed after RDFS and allows for the creation of more advanced ontologies {{cite:518cc121-f077-4b90-b757-241f8c31d5de}}. In OWL, cardinality restrictions, unions, and ontology dependencies were introduced. Semantic Web ontology languages, interestingly, are represented in RDF. Thus, FORMULA  is the set of all ontologies and their instances.
With RDF, RDFS, and OWL, a medium currently exists to model any physical or conceptual entity and their relationships to one another. The Semantic Web supports universal modeling and allows for the commingling of disparate heterogeneous models within a single substrate that can be used by humans and machines for any computational end. Any statement, logical or illogical, true or false, possible or impossible, can be made explicit in the Semantic Web. While the Semantic Web is primarily used to define descriptive models, there is nothing that prevents the representation of procedural models. In other words, models of computing can be explicitly represented in FORMULA . It is this modeling power that has prompted the growth of the semantic computing paradigm where the Semantic Web is no longer perceived solely as a universal data modeling medium, but also as a universal computing platform.
While the ideas presented in this article are amenable to any semantic network representation, this article will focus primarily on the Semantic Web due in large part to the technological infrastructure that currently supports this effort. This article's exploration will begin with a review of the various aspects of FORMULA . Next, a formal definition of computing will be presented in order to describe how the various components of computing can be represented by a semantic network. Current semantic network computing models will be placed within this semantic computing space. The definition of this space will expose areas that have yet to be developed and leave open the potential for future work in the area of semantic network computing.

Descriptive and Procedural Models
Currently, the Semantic Web is perceived primarily as a data modeling environment where data is more “descriptive" rather than “procedural" in nature {{cite:5c5b8e44-4d8f-4920-8455-9179afb34ac6}}. In other words, the triples in FORMULA  define a model, not the rules by which that model should evolve. This article will explore the more procedural aspects of FORMULA . Figure REF  presents an taxonomy of the various types of triples contained in FORMULA , where edges have the semantic “composed of".
FIGURE 
In its whole, FORMULA  is composed of nothing but triples. However, particular subsets of FORMULA  are used to represent different aspects of the larger FORMULA  model. Due to RDF, RDFS, and OWL, FORMULA  is composed of two main subnetworks: the ontological subnetwork and the instance subnetwork. While, in principle, anything can be modeled by a semantic network, most ontologies and instances are descriptive. However, there is nothing that prevents RDF from being used as a framework for denoting procedural models. That is, FORMULA  can be used to model functions (i.e. programs) and the machines that execute those functions.
This article will focus on the procedural aspects of FORMULA . Ontological procedural models represent machine architectures (i.e. abstract machines) and the abstract functions for which they process. On the other hand, instantiated procedures are stored programs (i.e. functions, algorithms, etc.) that are explicitly encoded for virtual machines (i.e. instances of an abstract machine architecture) to execute. The next section will present a formal description of computing.

Representing Computations in a One-Dimensional Tape
The classic notion of a computation is any process that can be explicitly represented by a formal algorithm. An algorithm is a sequence of executable, well-defined instructions {{cite:144018e7-5ec8-402d-8e62-36f0cf93399d}}. This sequence of instructions is executed by some system, or machine. This machine may contain, internal to it, all the requirements necessary to render the results of the algorithm or, in other instances, may rely on some external storage medium to read in novel inputs and write novel outputs. If the former computing model is chosen, then the machine can only execute a single algorithm with no variation on its behavior because no new input is altering its deterministic path (e.g. FORMULA ). However, if the latter model is chosen, the machine is general-purpose with respects to the particular “hard-wired" abstract algorithm. It is considered general-purpose because it can map any input to its respective output according to its abstract algorithm (e.g. FORMULA ).
This concept can be taken to its logical conclusion where a single machine can be engineered to perform any computing task. Paradoxically, that single machine executes one and only one algorithm. However, that particular algorithm is so generalized, that it can execute any number of other algorithms represented in the machine's external storage medium. This generalized algorithm can reach the “lowest common denominator" of computing and at that point, can even execute a representation of itself encoded in the storage medium. This machine is called a universal computing machine and is what is know today as the general-purpose computer. This idea was demonstrated by Alan Turing in the 1930s and is the foundation of the computer sciences {{cite:7d73c77f-1bee-4125-ba1e-11da5a900aff}}.
Modeling Computations using a Turing Machine
Perhaps the most common model used to represent computing is the Turing machine {{cite:e174286d-684f-47f7-8b35-68a1cdda14e3}}. In the Turing machine model of computation, FORMULA  is a machine with a single read/write head and FORMULA  is a storage medium called a “tape" that can be read from and written to by FORMULA . A Turing machine can be formalized by the 5-tuple
FORMULA 
where

FORMULA  is a set of machine states,

FORMULA  is a set of information symbols (e.g. 0,1),

FORMULA  is the transition/behavior function,

FORMULA  is the start state of the machine,

and FORMULA  is the start location of the machine head on FORMULA .

FORMULA  is a one-dimensional FORMULA -length vector of symbols from FORMULA  such that FORMULA .
A Turing machine, FORMULA , will start at state FORMULA  and cell FORMULA . Depending on what FORMULA  is read (FORMULA ) at FORMULA , FORMULA  will use its FORMULA  function to determine: 1.) what FORMULA  to write (FORMULA ) to FORMULA  or whether to erase (FORMULA ) the current symbol, 2.) whether to move its read/write head left (FORMULA ) or right (FORMULA ) on FORMULA , and finally 3.) determine which state in FORMULA  to transition to at the next time step,. This 5-tuple model is a simplified version of the 7-tuple representation in {{cite:750ffbb3-a4bc-4b72-b629-1727c16614da}}.
Let FORMULA  denote a Turing machine that increments a unary number by one. While this is not the most exciting algorithm, it is simple enough to represent succinctly and provides an example of the previous abstract concept. The FORMULA -function for FORMULA  is
TABLE 
where FORMULA  will write a 1 if a 0 exists at its current FORMULA , else it will move right and replay state A and the state B is considered the halt state. Thus, if FORMULA , FORMULA  will read the first 1, move right, read the second 1, move right, read the first 0, and write a 1. Upon entering state B, FORMULA . At the completion of this algorithm, the number 2 (11) is incremented to 3 (111). FORMULA  and FORMULA  are represented in Figure REF .
FIGURE 
Imagine having a single physical machine for every computation one required to execute. For instance, one would have an FORMULA  to add integers, an FORMULA  to divide floating-points, an FORMULA  to compare a string of characters, etc. To meet modern computing requirements, an unimaginable number of machines would be required. However, in fact, a single machine does exist for each computing need! Fortunately, these machines need not be physically represented, but instead can be virtually represented in FORMULA . This is the concept of the stored program and was serendipitously discovered by Alan Turing when he developed the idea of the universal Turing machine {{cite:e174286d-684f-47f7-8b35-68a1cdda14e3}}.

Modeling Computations using a Universal Turing Machine
A universal Turing machine, FORMULA , is a Turing machine that can execute the behavior of another Turing machine, FORMULA . This idea is a central tenet to the engineering of modern day computers. With a universal Turing machine, the state behavior of FORMULA  can be encoded on FORMULA  such that some FORMULA  can simulate the behavior of the FORMULA  encoded in FORMULA . In such cases, there exists another portion of FORMULA  that serves as the input/ouput to FORMULA  denoted FORMULA . This idea is depicted in Figure REF .
FIGURE 
The benefit of FORMULA  is that FORMULA  is a general-purpose machine that can be used to execute any algorithm. Thus, there need not exist separate physical machines for each algorithm. However, in order for FORMULA  to execute some FORMULA , FORMULA  must be encoded such that it is congruent with the expectations of FORMULA 's FORMULA -function. Thus, there exists an ontology, FORMULA , defining the requirements of the FORMULA  encoding. If some FORMULA  is represented according to FORMULA , then FORMULA  can execute it. In the lexicon of modern computing, if a program is written in native machine code, then the native machine can execute it.
Finally, to present the conclusion of this chain of reasoning, it is possible for FORMULA  to be encoded according to the FORMULA  ontology. Let FORMULA  denote the physical machine and FORMULA  denote the virtual FORMULA -encoded machine that is congruent with FORMULA . In such cases, FORMULA  can be used to execute some other FORMULA  in FORMULA . This idea is diagrammed in Figure REF . This idea is congruent with the concept of the virtual machine of modern day computing {{cite:1a93b40f-31a1-452b-b243-e7475de89a26}}.
FIGURE 

Representing Computations in a Semantic Network
While the Turing model of computing is very simple, it is actually quite representative of the current state of computing in semantic networks. The Semantic Web's FORMULA  is a data structure similar to FORMULA  except that FORMULA  is not a one-dimensional vector of FORMULA  symbols. While it is possible to represent FORMULA  as a one-dimensional string of FORMULA  symbols, the more intuitive and useful representation is that of a network of URIs (FORMULA ) and literals (FORMULA ). FORMULA  is a highly-distributed universal “tape" that can be accessed by machines world-wide for various computational purposes. However, how much of FORMULA  is leveraged for computing is machine-instance dependent.
Currently, the actual application that explicitly encodes subsets of FORMULA  is the triple-store (i.e. graph database, semantic repository, etc.). A triple-store is a database that contains a subset of the larger Semantic Web. The triple-store is the gatekeeper for determining how triples are read from and written to the Semantic Web. Unlike the read/write head of the Turing machine, the machines that access FORMULA  are able to move about FORMULA  in a more random-access fashion due to the development of the common variable-binding interface. While any other FORMULA  interface may be developed in the future, the lowest-level requirements of such an interface are the ability to read, write, and delete triples from FORMULA . This section will discuss the nature of a primitive read/write interface into FORMULA  and its relation to FORMULA -computing.

——
As demonstrated by Alan Turing, the most primitive components required for a computing machine are the ability to read and write to a medium and alter its states according to its perception of that medium. Similar to the relationship between FORMULA  and FORMULA , it is possible to develop a semantic Turing machine that is able to read/write to FORMULA  and evolve its state behavior accordingly.
A semantic Turing machine is denoted FORMULA  and can be formalized by the 5-tuple
FORMULA 
where

FORMULA  is a set of machine states,

FORMULA  is the set of URI and literal symbols,

FORMULA  is the transition/behavior function,

FORMULA  is the start state of the machine,

and FORMULA  is a set of random access machine heads.

These components will be discussed in full throughout the remainder of this section.
The most readily used low-level read model for the Semantic Web is the 3-element symbol binding model,
FORMULA 
where FORMULA  is called a query, FORMULA , and the elements FORMULA , FORMULA , and FORMULA  can either be drawn from the set FORMULA  or from the set of machine heads defined by FORMULA . If those heads in FORMULA  are declared bindings, then the machine head is random access. In a semantic Turing machine, there does not exist an explicit move behavior. If a state FORMULA  is to move a random access head, then it places a bind-symbol before the head name (e.g. FORMULA ) otherwise the machine will hold its head at its current pointed to location with a static-symbol (e.g. FORMULA ). For instance, FORMULA  would place the head FORMULA  on some object of a triple with the subject marko and predicate isA. If FORMULA  bound to FORMULA  then FORMULA . However, if the machine head is already at a particular resource in FORMULA , then it can be used as a static variable. If FORMULA  bound to human on a previous read, then FORMULA  will move FORMULA  to the resource mammal. With the random-access FORMULA  machine heads, no variable states are represented internal to FORMULA , they are simply pointed to by some FORMULA  in FORMULA .
The most readily used write model for the Semantic Web is to union the semantic network triple list FORMULA  with a new triple FORMULA ,
FORMULA 
where FORMULA , FORMULA , FORMULA , and FORMULA .
Finally, in order to erase (i.e. delete) a triple, the 3-element symbol binding model can be used,
FORMULA 
where the triple FORMULA  is removed from FORMULA .
An FORMULA  can be built to do any type of computation on FORMULA . The popular Horn-clause query/assertion can be represented by an FORMULA  {{cite:028f19a3-1f5d-44e1-9317-c9198e1a6095}}. For instance, the rule

 hasParent(marko,?x1)   hasBrother(?x1,?x2)
  hasUncle(marko,?x2)

states that if marko has a parent that binds to FORMULA  and FORMULA  has a brother that binds to FORMULA  then assert (i.e. write) the fact that FORMULA  is marko's uncle. The FORMULA -function for FORMULA  that executes this query is
TABLE 
where FORMULA , C is the halt state, FORMULA  and FORMULA  is the state transition when a FORMULA  fails. If

G={marko, hasParent, carole ,
   carole, hasBrother, george },

then at FORMULA , FORMULA  will point to carole, at FORMULA , FORMULA  will point to george, and at FORMULA ,

G={marko, hasParent, carole ,
   carole, hasBrother, george
   marko, hasUncle, george }.
For more arithmetic operations and for the construction of novel URIs and literals, the classic Turing machine model can be used for writing triples that bind symbols in a list-like fashion. In other words, a semantic network can simulate a one-dimensional tape. In this model, the semantic Turing machine utilizes only FORMULA  for its workspace computations and the semantic Turing machine is analogous in terms of its component parts to the classic Turing machine. The FORMULA -function to increment a unary number by 1 is
TABLE 
where the URI bit1 is the subject of the triple whose object is the first bit of the unary number. While it is possible to perform low-level arithmetic calculations in FORMULA , constructing such a machine is impractical. Unlike a physical FORMULA  where the laws of physics are the computing substrate, FORMULA s are embedded in a substrate that was engineered for computing–the general-purpose processor. Thus, an FORMULA  can rely on its local processor for arithmetic computations and for the construction of new URIs and literals. What was presented previous was only to demonstrate that FORMULA  can be used as a universal computing “tape". However, how much of computing is represented in FORMULA  is implementation specific, but the more a computation is represented in FORMULA , the more the Semantic Web can be made to behave like a general-purpose computer.
Finally, it is possible to represent the previous two FORMULA -functions in FORMULA  such that some FORMULA  external to FORMULA  is able to simulate the behavior of these respective FORMULA  machines. In this sense, FORMULA  is a universal semantic Turing machine and any FORMULA  that obeys the FORMULA  ontology can be executed by FORMULA . The next section will discuss moving computations into FORMULA  to ultimately arrive at a general-purpose computer embedded in FORMULA –a semantic virtual machine.

The Semantic Web as a General-Purpose Computer
The current state of the Semantic Web is such that machines (i.e. processes) exist external to FORMULA  and manipulate FORMULA  by reading, writing, and deleting triples to and from it. In many cases, FORMULA  does not encode stored programs in the Turing sense. Those processes that manipulate FORMULA  use some other FORMULA -medium (e.g. local memory) for their respective calculations. However, by leveraging external FORMULA -mediums that are not FORMULA , there exist multiple machines (i.e. software programs) that do very specific computing tasks. This is analogous to having different physical FORMULA s for each desired computing task. On the other hand, when FORMULA  is leveraged as the sole substrate for encoding information, then it is possible to not only use FORMULA  for stored programs, but also to use FORMULA  to represent a universal computing machine {{cite:81eda60e-40bd-4239-a528-1865e8a624bf}}. The benefit of this latter model is that the Semantic Web becomes a universal computing platform, where any number of universal computing machines exist external to FORMULA  executing the state evolution of those FORMULA  encoded machines. At this stage, FORMULA  is a massive computer distributed across servers world-wide.
The remainder of this section will present the various levels of machine encodings currently realized by the Semantic Web community. The first is the “external program" level where FORMULA  machines are external processes whose stored programs are represented in some other FORMULA -medium. The second level is the “stored program" level where FORMULA  machines are external process whose stored programs are represented in FORMULA . The final level is called the “virtualized machine" level where FORMULA  machines are internal processes represented in FORMULA  whose stored programs are also represented in FORMULA .
The External Program Model
In the external program model, the Semantic Web is considered a database. The machines (i.e. programs) developed for FORMULA  exist external to FORMULA  and only use FORMULA  for reading descriptive data (and possibly writing descriptive data). This is analogous to the physical manifestation of an algorithm in the Turing model of computing. While it is possible for FORMULA  to be completely configurable and thus, not “hard coded", this FORMULA -function is stored in a separate FORMULA -medium where FORMULA . Therefore, with respects to FORMULA  as a general computing platform, this model is the farthest removed from this vision.
One such example of the external program model is the SPARQL query language {{cite:4349b8d9-4eef-44e0-9daa-619e017b681e}}. The SPARQL query language is a Horn-based {{cite:028f19a3-1f5d-44e1-9317-c9198e1a6095}} query language that supports semantic searching in FORMULA . For instance, the following example SPARQL query
SELECT ?x
WHERE { marko isA ?x . }
will bind FORMULA  to all URIs that are the object of a triple that has marko as the subject and isA as the predicate. While a universal SPARQL machine, denoted FORMULA , can execute any SPARQL-proper query, these queries (i.e. programs) are not explicitly represented in FORMULA , but instead in some FORMULA . Thus, with respects to FORMULA , each SPARQL query is analogous to a unique FORMULA . Furthermore, the output from any FORMULA  is encoded in FORMULA  (more specifically FORMULA ). In this sense, FORMULA  is only used as the input parameter to FORMULA , not as a computational “workspace". This computing model is diagrammed in Figure REF , where FORMULA  is the universal SPARQL machine, FORMULA  is a particular SPARQL query, and FORMULA  is the result set derived from the execution of FORMULA  on FORMULA .
FIGURE 
It is no large conceptual leap to actually encode SPARQL queries in RDF and therefore, in FORMULA . In fact, the semantic network data structure is an ideal medium for many types of information encodings due to its generalized network nature that naturally supports the expression of trees, lists, graphs, tables, etc. The next subsection will discuss such stored programs.

The Stored Program Model
In the stored program model, FORMULA  is a universal machine that reads its parameter specification from FORMULA  and writes its algorithm's output to FORMULA . Thus, the specification of the FORMULA -function of any FORMULA  is encoded in FORMULA .
One such example of the stored program model is the Semantic Web Rule Language (SWRL). SWRL is a Horn-clause based query/assertion language similar to SPARQL {{cite:a9eb0ea3-5e6e-44e3-8c72-e040d7078641}}. For example, in the “my friend is your friend" query/assertion

 hasFriend(?x1,?x2)   hasFriend(?x2,?x3)
  hasFriend(?x1,?x3)

if FORMULA  has a friend FORMULA  and FORMULA  has a friend FORMULA , then FORMULA  and FORMULA  are asserted to be friends. Interestingly, SWRL query/assertions can be represented in RDF and thus, can be explicitly encoded in FORMULA . The benefit of this is that there can exist a generalized SWRL machine denoted FORMULA  that can point to any particular FORMULA  in FORMULA . This idea is depicted in Figure REF , where FORMULA  is a universal SWRL machine, FORMULA  is a particular SWRL query/assertion, and FORMULA  is the result of the execution of FORMULA . However, note that FORMULA  is the computational workspace for FORMULA , not FORMULA .
FIGURE 
While SWRL FORMULA  is Turing complete {{cite:e0933d28-47dc-40c5-a772-6aa516b2ec96}}, it is impractical to represent arithmetic and loop-based algorithms in SWRL. This means that there exists algorithms for which SWRL FORMULA  can not easily emulate. As a remedy to this problem, two Turing complete FORMULA  machines were developed: the stack-based Ripple {{cite:5c5b8e44-4d8f-4920-8455-9179afb34ac6}} and the RAM-based r-Fhat {{cite:81eda60e-40bd-4239-a528-1865e8a624bf}}. For Ripple and r-Fhat, like SWRL, their respective programs are encoded in FORMULA . However, both Ripple and r-Fhat maintain their respective universal machine data structures in FORMULA  for computing local operations and thus, do not completely use FORMULA  as their computing workspace.
In the stored program model, there not only exists descriptive data in FORMULA , but also procedural data. In many cases, there also exists an ontology FORMULA  that defines the structure of that procedural data. In general, if a subset of FORMULA  obeys FORMULA , then it is computable by FORMULA . The next subsection will discuss full machine virtualization and the explicit representation of FORMULA .

The Virtualized Machine Model
The previous section discussed the explicit encoding of stored programs in FORMULA . However, there is nothing preventing the stored program from being a computing machine. In this model, a virtual machine is encoded in FORMULA  along with the programs that the virtual machine executes. In order to represent a virtual machine in FORMULA  is it necessary to support a write/delete interface to FORMULA  since the machine evolution and its effect on FORMULA  is the computation.
Currently, the only example of a virtualized machine encoded in FORMULA  is the Fhat RVM (RDF virtual machine) {{cite:81eda60e-40bd-4239-a528-1865e8a624bf}}. A Fhat processor, denoted FORMULA  exists internal to FORMULA . Another process FORMULA  external to FORMULA  is a general-purpose machine that reads FORMULA  from FORMULA  as if it were any other program. However, FORMULA  is not only a program, but is another machine that is executing an algorithm, FORMULA , in another area of FORMULA , FORMULA . The virtualized machine model is depicted in Figure REF .
FIGURE 
There is nothing that prevents the FORMULA  that FORMULA  is executing from being another FORMULA . For example, imagine two FORMULA  machines encoded in FORMULA : FORMULA  and FORMULA , where FORMULA . The external FORMULA  can be reading in FORMULA  as a program, which is reading in FORMULA  as a program, which is reading in some other machine FORMULA  as a program. In this model, there is no limit to the amount of computing redirection that is possible. Ultimately, it is up to the external FORMULA  to perform all the read/write operations that update the respective states of all the chained together FORMULA  machines.
In the virtual machine model, not only is procedural data encoded in FORMULA , but also machine data. There must exist both an ontology for procedural data FORMULA  and an ontology for machine data FORMULA . In principle, any subset of FORMULA  that obeys FORMULA  is a virtualized computing machine.

True Universality
While a universal semantic Turing machine can be created, it is impractical to do so because of the speed constraints currently realized by the read/write interface to the Semantic Web and because any external FORMULA  already exists in a substrate engineered for general-purpose computing. Therefore, for virtualized semantic machines, FORMULA -mediums are currently used for low-level arithmetic operations only. There will always be a tradeoff between the desire to represent low-level computations in FORMULA  and the desire to ensure the fast execution of those FORMULA -based machine representations.
The Fhat processor was designed with this constraint in mind. Many aspects of the machine's state are represented in FORMULA  including its operand stack, symbol table, program counter, etc. However, when a low-level operation such as add 2 3 is called, those values are calculated on the physical machine, not in FORMULA . While this may not be completely theoretically satisfying, it does support a practical implementation of the virtual machine model of computing in FORMULA .

The Future of Semantic Network Computing
The future of semantic network computing may be one in which virtual machines and their programs exist in FORMULA . Any universal machine external to FORMULA  can gain access to the URI denoting a virtual machine and begin to execute its “physics". In other words, evolve its state and compute. In this idealized world, the underlying physical hardware supporting the execution of these virtual machines is more or less inconsequential. These underlying hardware processors are analogous to the underlying physics supporting the execution of our hardware machines. Once the protocols are in place to ensure that FORMULA  has a farm of processors continuously evolving it, then the Semantic Web will have reached a transition to where abstract virtualized computing becomes ubiquitous and FORMULA  can be seen as a single distributed computer with the massive address space of FORMULA . However, there are still many obstacles that prevent this model from becoming a common reality.
First, the read/write speeds for FORMULA  are orders of magnitude slower than the read/write speeds for local memory and thus, computing in FORMULA  is orders of magnitude slower. There is still much more room for growth in the area of triple-store index algorithms. Unlike the relational database model where data is broken into different linked tables, the triple-store is a single massive table with various indexes supporting fast searching. As the read/write speeds continue to increase, the ability to use FORMULA  as a computing “tape" will become more viable.
Third, current triple-store's have limits on the number of triples they can feasibly represent in a single store. While some stores can easily support up to FORMULA  triples, the explicit representation of procedural data reduces the amount of space available for descriptive data. Fortunately, with an increase in the use of standards liked Linked Data {{cite:213aaae4-372e-4636-8157-04db3113fd69}}, the growth of FORMULA  will have limited effect on the ability to compute in FORMULA .
Fourth, the current state of affairs in the Semantic Web is such that writing to FORMULA  is cumbersome due to the absence of a generally accepted protocol to do so. While the proposed SPARQL/Update protocol {{cite:c0bf158b-7686-4561-9a7e-5e08bcf63111}} is one such write interface, it is not widely supported by all triple-store providers. Thus, each triple-store provider maintains their own mechanism for writing and deleting triples.
Finally, there does not exist a universal trust and security mechanism to deter malicious machines in FORMULA . If FORMULA  is conceived as a a universal computing “tape", then the read, and more importantly, write/delete accesses to FORMULA  will need to be established. Of course, FORMULA  is only contained in an abstract universal store. Each triple-store supports only a subset of the larger whole. Therefore, for those running a triple-store, read/write privileges is not an issue. However, as more procedural information is encoded in FORMULA  and machines can share procedural fragments, understanding where particular bits of information were derived from becomes very important. Work in the area of named graphs for trust and provenance should prove promising in this area {{cite:2cb7e5dd-9c69-410d-b37b-b802f2b42a7a}}. The named graph extends the triple concept by adding an extra resource called FORMULA , or graph. A triple is thus a quad and FORMULA . The FORMULA  component of FORMULA  is a URI and this information can be used to attach read/write privileges to particular subnetworks of FORMULA .
While this list is not conclusive, it provides an overview of some of the more prominent issues concerning the future of semantic network computing.

Conclusion
Given that the Semantic Web is an abstract data structure, it does not have the capacity to perform a computation in and of itself. The Semantic Web is simply a description of the relationship between URIs and literals and, in order to evolve, it requires the explicit contribution of external machines to read and write to it. However, the amount of procedural information that is actually encoded in the Semantic Web can vary. At one extreme, the Semantic Web is a read-only substrate that has limited effect on how a computation evolves. At the other extreme, the Semantic Web is the representational substrate for not only the data aspects of a computation, but also the algorithmic and machine representations as well.
This article has presented an analysis of the various models of computing in the Semantic Web and in semantic networks in general. It is the hope that more research and development will go into developing practical computing environments that leverage FORMULA  as their computing substrate.

Acknowledgments
Marko A. Rodriguez and Johan Bollen are funded by a grant from the Andrew W. Mellon Foundation.
